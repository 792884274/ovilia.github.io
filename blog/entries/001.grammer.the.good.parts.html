<div class="citeLeft"></div><div class="cite">    <p>有无相生，难易相成；长短相较，高下相倾；音声相和，前后相随。</p>    <p class="citeFrom">——老子《道德经》</p>    <p>It is that existence and non-existence give birth the one to the other; that difficulty and ease produce the one to the other; that length and shortness fashion out the one the figure of the other; that height and lowness arise from the contrast of the one with the other; that the musical notes and tones become harmonious through the relation of one with another; and that being before and behind give the idea of one following another.</p>    <p class="citeFrom">--Laozi, Tao Te Ching</p></div><p>JavaScript is a powerful programing language, yet with some uglily designed parts. But it is the ugliness that defines beauty so that JavaScript should not be the one to be blamed.</p><p>The goal of the book, <span class="term">JavaScript: The Good Parts</span> is to dig out the best nature of it and try to avoid the bad parts. The book has chapters on <span class="term">Grammar</span>, <span class="term">Objects</span>, <span class="term">Functions</span>, <span class="term">Inheritance</span>, <span class="term">Array</span> and etc. And I will paste the important words from the book and do experiments with them.</p><p>Now, let's begin with Grammar.</p><p class="title">Comments</p><p>You must be familiar with comments in the form of <span class="code">//</span> or <span class="code">/* */</span>.</p><p>Personally, I would use <span class="code">//</span> for temporary comments and use <span class="code">/* */</span> in most final cases. I can't remember where I learned this style from, but I guess it was from a C++ book. But once you write in JavaScript, you should think in JavaScript.</p><div class="citeLeft"></div><div class="cite">    <p>The <span class="code">/* */</span> form of block comments came from a language called PL/I. PL/I chose those strange pairs as the symbols for comments because they were unlikely to occur in that language’s programs, except perhaps in string literals. In JavaScript, those pairs can also occur in regular expression literals, so block comments are not safe for commenting out blocks of code.</p>    <p>For example: <span class="code">/* var rm_a = /a*/.match(s); */</span> causes a syntax error. So, it is recommended that <span class="code">/* */</span> comments be avoided and <span class="code">//</span> comments be used instead.</p>    <p class="citeFrom">--JavaScript: The Good Parts</p></div><p>So now we learned that it's recommended to use <span class="code">//</span> instead of <span class="code">/* */</span> in JavaScript. But I believe this doesn't necessarily to be true and you may choose your favorite style and stay consistent. But do remember the side effect mentioned here.</p><p>Here's something about <span class="code">//</span> in strings.</p><pre class="brush: js; toolbar: false;">    // In JavaScript string, you don't need to escape /    var a = "a/b";          // will give "a/b"         // But if you use \, it can be escaped    var b = "a\/b";         // will also give "a/b"         // While \ should always be escaped    var c = "a\b";          // will give "a" since \b means a backspace,                             // which does nothing special here         // The right way for a \    var d = "a\\b";         // will give "a\b" as expected</pre><p>Note that <span class="code">//</span> inside of a string will not make a comment.<p><pre class="brush: js; toolbar: false;">    // This will give "a//b" without an error    var e = "a//b";         </pre><p class="title">Name</p><p>Reserved words:</p><p class="code">abstract boolean break byte case catch char class const continue debugger default delete do double else enum export extends false final finally float for function goto if implements import in instanceof int interface long native new null package private protected public return short static super switch synchronized this throw throws transient true try typeof var volatile void while with</p><p>It is easier than you think to make the mistake of using these reserved words. I used to spend a lot of time debugging someone else's programe and thanks to IDE syntax highlighter, I finally realized that he used the reserved word <span class="code">in</span>. You may possibly not take words like <span class="code">interface</span>, <span class="code">native</span> and <span class="code">package</span> as reserved words. So, be careful next time.</p><div class="citeLeft"></div><div class="cite">    <p>Most of the reserved words in this list are not used in the language. The list does not include some words that should have been reserved but were not, such as <span class="code">undefined</span>, <span class="code">NaN</span>, and <span class="code">Infinity</span>. It is not permitted to name a variable or parameter with a reserved word. Worse, it is not permitted to use a reserved word as the name of an object property in an object literal or following a dot in a refinement.</p>    <p class="citeFrom">--JavaScript: The Good Parts</p></div><p class="title">Number</p><div class="citeLeft"></div><div class="cite">    <p>JavaScript has a single number type. Internally, it is represented as 64-bit floating point, the same as Java’s <span class="code">double</span>. Unlike most other programming languages, there is no separate integer type, so <span class="code">1</span> and <span class="code">1.0</span> are the same value.</p>    <p class="citeFrom">--JavaScript: The Good Parts</p></div><div class="citeLeft"></div><div class="cite">    <p>The value <span class="code">NaN</span> is a number value that is the result of an operation that cannot produce a normal result. <span class="code">NaN</span> is not equal to any value, including itself. You can detect <span class="code">NaN</span> with the <span class="code">isNaN(number)</span> function.</p>    <p class="citeFrom">--JavaScript: The Good Parts</p></div><div class="citeLeft"></div><div class="cite">    <p>The value <span class="code">Infinity</span> represents all values greater than <span class="code">1.79769313486231570e+308</span>.</p>    <p class="citeFrom">--JavaScript: The Good Parts</p></div><p class="title">String</p><div class="citeLeft"></div><div class="cite">    <p>The <span class="code">\u</span> convention allows for specifying character code points numerically. <span class="code">"A" === "\u0041"</span>.</p>    <p class="citeFrom">--JavaScript: The Good Parts</p></div><p>In the above case, the length of the character "\u0041" is still 1.<p><pre class="brush: js; toolbar: false;">    var f = "\u0041".length         // f is 1</pre><p class="title">Statements</p><div class="citeLeft"></div><div class="cite">    <p>A block is a set of statements wrapped in curly braces. Unlike many other languages, blocks in JavaScript do not create a new scope, so variables should be defined at the top of the function, not in blocks.</p>    <p class="citeFrom">--JavaScript: The Good Parts</p></div><p>This is a very important feature of JavaScript. I'll explain in the following examples.</p><p>For languages create scopes by blocks, like C++ and Java, variables defined inside the block cannot be accessed outside of the block. As the following code shows. If the following code is written in C++ and you try to get or set value of <span class="code">abc</span> in 4th line, there will be an error at compiling time.</p><pre class="brush: js; toolbar: false; highlight: 2">    if (true) {        int abc = 2;    }    // abc cannot be accessed here</pre><p>But if it is in JavaScript as the following code shows, it's totally legal to access <span class="code">efg</span> outside the <span class="code">if</span> block. The 2rd line just adds the variable <span class="code">efg</span> to current scope, which is global scope in this case. So, outside the block, <span class="code">efg</span> still exists in the global scope.</p><pre class="brush: js; toolbar: false; highlight: 2">    if (true) {        var efg = 2;    }    // efg is 2 here        // efg is still 2 even if re-defined    // althrough it does nothing in this case    var efg;</pre><p>Similarly, variables defined in the initialization part of a <span class="code">for</span> loop can be accessed afterwards. So you should pay additional attention to them if they are used later.</p><pre class="brush: js; toolbar: false;">    for (var i = 0; i < 10; ++i) {            }    // i is 10 here, rather then undefined</pre><div class="citeLeft"></div><div class="cite">    <p>The <span class="code">if</span> statement changes the flow of the program based on the value of the expression. The then block is executed if the expression is <span class="term">truthy</span>; otherwise, the optional <span class="code">else</span> branch is taken.</p>    <p class="citeFrom">--JavaScript: The Good Parts</p></div><p>That sounds trivial. But the importance lies in what is <span class="term">truthy</span>.</p><div class="citeLeft"></div><div class="cite">    <p>Here are the falsy values:</p>    <ul>        <li>false</li>        <li>null</li>        <li>undefined</li>        <li>The empty string ''</li>        <li>The number 0</li>        <li>The number NaN</li>    </ul>    <p>All other values are truthy, including <span class="code">true</span>, the string <span class="code">'false'</span>, and all <span class="code">objects</span>.</p>    <p class="citeFrom">--JavaScript: The Good Parts</p></div>