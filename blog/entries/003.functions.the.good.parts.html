<div class="citeLeft"></div>
<div class="cite">
    <p>The best thing about JavaScript is its implementation of functions. It got almost everything right. But, as you should expect with JavaScript, it didn't get everything right.</p>
    <p class="citeFrom">--JavaScript: The Good Parts</p>
</div>

<p class="title">Function Objects</p>
<div class="citeLeft"></div>
<div class="cite">
    <p>Functions in JavaScript are objects.</p>
    <p>Function objects are linked to <span class="code">Function.prototype</span> (which is itself linked to <span class="code">Object.prototype</span>).</p>
    <p class="citeFrom">--JavaScript: The Good Parts</p>
</div>



<p class="title">Invocation</p>
<div class="citeLeft"></div>
<div class="cite">
    <p>In addition to the declared parameters, every function receives two additional parameters: <span class="code">this</span> and <span class="code">arguments</span>.</p>
    <p>There are four patterns of invocation in JavaScript: the method invocation pattern, the function invocation pattern, the constructor invocation pattern, and the apply invocation pattern. The patterns differ in how the bonus parameter <span class="code">this</span> is initialized.</p>
    <p class="citeFrom">--JavaScript: The Good Parts</p>
</div>

<p>The method invocation pattern:</p>
<pre class="brush: js; toolbar: false">
    var obj = {
        a: 0,
        b: function(c) {
            this.a += c;
        }
    }
</pre>

<p>The function invocation pattern:</p>
<pre class="brush: js; toolbar: false">
    var a = function() {};
    a();
</pre>
<div class="citeLeft"></div>
<div class="cite">
    <p>When a function is not the property of an object, then it is invoked as a function.</p>
    <p>When a function is invoked with this pattern, <span class="code">this</span> is bound to the global object. This was a mistake in the design of the language. Had the language been designed correctly, when the inner function is invoked, <span class="code">this</span> would still be bound to the this variable of the outer function. A consequence of this error is that a method cannot employ an inner function to help it do its work because the inner function does not share the method's access to the object as its <span class="code">this</span> is bound to the wrong value.</p>
    <p>Fortunately, there is an easy workaround. If the method defines a variable and assigns it the value of <span class="code">this</span>, the inner function will have access to this through that variable. By convention, the name of that variable is <span class="code">that</span>:</p>
    <pre class="brush: js; toolbar: false; highlight: 3">
        // Augment myObject with a double method.
        myObject.double = function() {
            var that = this; // Workaround.
            var helper = function() {
                that.value = add(that.value, that.value);
            };
            helper(); // Invoke helper as a function.
        };
        
        // Invoke double as a method.
        myObject.double();
        document.writeln(myObject.value);
    </pre>
    <p class="citeFrom">--JavaScript: The Good Parts</p>
</div>

<p>The constructor invocation pattern:</p>
<pre class="brush: js; toolbar: false; highlight: [2, 6, 10]">
    var A = function(b) {
        this.c = b;
    }
    
    A.prototype.getC = function() {
        return this.c;
    }
    
    var a = new A(2);
    a.getC();
</pre>
<div class="citeLeft"></div>
<div class="cite">
    <p>Use of this style of constructor functions is not recommended. We will see better alternatives in the next chapter.</p>
    <p class="citeFrom">--JavaScript: The Good Parts</p>
</div>

<p>The apply invocation pattern:</p>
<div class="citeLeft"></div>
<div class="cite">
    <p>The <span class="code">apply</span> method lets us construct an array of arguments to use to invoke a function. It also lets us choose the value of <span class="code">this</span>. The <span class="code">apply</span> method takes two parameters. The first is the value that should be bound to <span class="code">this</span>. The second is an array of parameters.</p>
    <p class="citeFrom">--JavaScript: The Good Parts</p>
</div>
<pre class="brush: js; toolbar: false; highlight: [11, 12, 14]">
    var a = 1, b = 2;
    var obj = {
        a: 3,
        b: 4
    };
    
    function add(c, d) {
        return this.a + this.b + c + d;
    }
    
    add.apply(window, [10, 20]);    // 33
    add.apply(null, [10, 20]);      // 33
    
    add.apply(obj, [10, 20]);       // 37
</pre>



<p class="title">Exceptions</p>
<div class="citeLeft"></div>
<div class="cite">
    <p>JavaScript provides an exception handling mechanism. Exceptions are unusual (but not completely unexpected) mishaps that interfere with the normal flow of a program. When such a mishap is detected, your program should throw an exception:</p>
    <pre class="brush: js; toolbar: false;">
        var add = function (a, b) {
            if (typeof a !== 'number' || typeof b !== 'number') {
                throw {
                    name: 'TypeError',
                    message: 'add needs numbers'
                };
            }
            return a + b;
        }
        
        var try_it = function() {
            try {
                add("seven");
            } catch(e) {
                document.writeln(e.name + ': ' + e.message);
            }
        }
        try_it();
    </pre>
    <p class="citeFrom">--JavaScript: The Good Parts</p>
</div>
